#!/usr/bin/env python

# -----------------------------------------------------------------------------
# The copyright notice below is for the SCons build scripts included with this
# software, which were initially developed by Michael Park
# (see https://github.com/mpark/bob) and customized at Tagged.  Many thanks to
# Michael for this useful contribution.
# _____________________________________________________________________________

# -----------------------------------------------------------------------------
# The MIT License (MIT)
# Copyright (c) 2014 Michael Park
# Copyright (c) 2014 Tagged
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# -----------------------------------------------------------------------------

import functools
import os.path
import subprocess
import sys

import SCons.Scanner.C

# Import variables.
Import(['env', 'src', 'out'])

# Our scanner.
scanner = SCons.Scanner.C.CScanner()

# Current working directory.
cwd = Dir(Dir(GetLaunchDir()).get_path(src))

# Set of supported extensions.
exts = {env[suffix] for suffix in {'PROGSUFFIX',
                                   'LIBSUFFIX',
                                   'SHLIBSUFFIX',
                                   'OBJSUFFIX',
                                   'SHOBJSUFFIX',
                                   'TESTSUFFIX'}}


# Input parameter 'target_path' is a filename which may represent a header
# file, object file, or library.  For instance, some possibilities are:
#
#     'foo/bar.h'
#     'foo/bar.o'
#     'foo/bar.a'
#     'foo/bar.so'
#
# Look for a corresponding non-header C or C++ source file, where the possible
# file suffixes are defined by input list 'dep_suffixes'.  For instance, if
# dep_suffixes is [ '.cc', '.cpp', '.c' ] then the possibilities are:
#
#     'foo/bar.cc'
#     'foo/bar.cpp'
#     'foo/bar.c'
#
# If no such non-header is found, return None.  If exactly one such non-header
# is found, return a File object representing it.  If for some crazy reason,
# multiple such non-headers are found (for instance, both 'foo/bar.cc' and
# 'foo/bar.c'), halt with an error message.  If parameter 'cwd_rel' is True,
# then 'target_path' is interpreted as relative to the current working
# directory.  Otherwise 'target_path' is interpreted as relative to 'src'.
def get_one_dep_source(target_path, dep_suffixes, cwd_rel):
    (prefix, suffix) = os.path.splitext(target_path)
    gen_map = env['GENERATED_SOURCE_MAP']

    if gen_map.has_key(target_path):
        result = gen_map[target_path]
    else:
        result = None

    for elem in dep_suffixes:
        if cwd_rel:
            dep_source = cwd.File(prefix + elem)
        else:
            dep_source = File(prefix + elem)

        if dep_source.srcnode().exists():
            if result is not None:
                path1 = prefix + os.path.splitext(result.get_path())[1]
                path2 = prefix + os.path.splitext(dep_source.get_path())[1]
                sys.stderr.write('Ambiguous sources for ' + target_path +
                        ': ' + path1 + ' ' + path2 + '\n')
                sys.exit(1)

            result = dep_source

    return result


# If parameter 'main' is None, return None.  Otherwise, recursively find all of
# the object files that main depends on, and return the result as a list of
# File objects.
def get_dep_sources(main):
    def impl(source_set, result):
        if not source_set:
            return result

        result |= source_set
        dep_source_set = set()

        for source in source_set:
            if not source.srcnode().exists():
                continue  # source file is generated during build

            for dep_header in source.get_implicit_deps(env, scanner, (src,)):
                dep_source = get_one_dep_source(dep_header.get_path(src),
                                                env['DEP_SUFFIXES'], False)

                if dep_source is not None and dep_source not in result:
                    dep_source_set.add(dep_source)

        return impl(dep_source_set, result)

    if main is None:
        return None

    dep_source_set = impl({main}, set())

    # Sort the dependencies so their order is consistent.  If the order changes
    # from one build to the next, SCons will rebuild the target unnecessarily
    # because the dependency order changed.
    result = [elem for elem in dep_source_set]
    result.sort(key=lambda elem: str(elem))
    return result


# Execute the test and check that the return code is 0.
def run_test(target, source, env):
    for test in source:
        try:
            subprocess.check_call(test.get_path())
        except subprocess.CalledProcessError:
            sys.stderr.write('Test failed\n')
            sys.exit(1)


# Tell SCons how to generate bruce/version.cc from bruce/version.cc.in.
ver_out_node = Dir('bruce').File('version.cc')
ver_out = ver_out_node.get_path()
ver_in = Dir('bruce').File('version.cc.in').get_path()
ver_script = Dir('bruce').Dir('scripts').File('gen_version').get_path()
version_script_abs_path = src.Dir('bruce').Dir('scripts').File('gen_version') \
        .get_path()
env.Command(ver_out, [ver_in, ver_script],
        version_script_abs_path + " -g < $SOURCE > $TARGET")

# Specify that bruce/version.h depends on bruce/version.cc, which is generated
# during the build.  This information is taken into account when dependencies
# are computed.
env['GENERATED_SOURCE_MAP'][Dir('bruce').File('version.h').get_path()] = \
        ver_out_node

# For each given target path, try to build it.
for target_path in BUILD_TARGETS:
    target = cwd.File(target_path)
    ext = os.path.splitext(target_path)[1]

    # Validate that the file kind is supported.
    if ext not in exts:
        sys.stderr.write(
                'Invalid extension: "{ext}" (choose from {exts})'.format(
                ext=ext,
                exts=', '.join(['"{ext}"'.format(ext=ext) for ext in exts])) +
                '\n')
        sys.exit(1)

    source = {env['PROGSUFFIX'] : lambda:
                  get_dep_sources(get_one_dep_source(target_path,
                          env['DEP_SUFFIXES'], True)),
              env['LIBSUFFIX']  : lambda:
                  get_dep_sources(get_one_dep_source(target_path,
                          env['DEP_SUFFIXES'], True)),
              env['SHLIBSUFFIX']: lambda:
                  get_dep_sources(get_one_dep_source(target_path,
                          env['DEP_SUFFIXES'], True)),
              env['OBJSUFFIX']  : lambda: get_one_dep_source(
                          target_path, env['DEP_SUFFIXES'], True),
              env['SHOBJSUFFIX']: lambda: get_one_dep_source(
                          target_path, env['DEP_SUFFIXES'], True),
              env['TESTSUFFIX'] : lambda:
                  get_dep_sources(get_one_dep_source(target_path, ['.test.cc'],
                          True))
              }[ext]()

    if source is None:
        sys.stderr.write('Source for target ' + target_path + ' not found\n')
        sys.exit(1)

    # Choose the correct builder based on the target_path's extension.
    {env['PROGSUFFIX'] : functools.partial(env.Program, LIBS=env['PROG_LIBS']),
     env['LIBSUFFIX']  : env.Library,
     env['SHLIBSUFFIX']: env.SharedLibrary,
     env['OBJSUFFIX']  : env.Object,
     env['SHOBJSUFFIX']: env.SharedObject,
     env['TESTSUFFIX'] : functools.partial(env.Program, LIBS=env['TEST_LIBS'])
    }[ext](target, source)

    # If target is a unit test, execute it.
    test = None

    if GetOption('test') and ext == env['TESTSUFFIX']:
        test = env.Command(None, target,
                           Action(run_test, 'Running test: $SOURCE'))

    env.Alias(target_path, [target, test])
